=begin pod

=CHAPTER Операторы

=config C<> :allow<E>
X<|оператор>
 
X<Операторы|оператор> обеспечивают простой синтаксис для часто используемых действий. Они обладают специальным синтаксисом и позволяют манипулировать значениями.
 
Вернемся к нашей турнирной таблице из предыдущей главы. Допустим вам потребовалось графически отобразить количество выигранных каждым игроком сетов в турнире. Следующий пример выводит на экран строки из символов C<X> для создания горизонтальной столбчатой диаграммы:
 
=begin code
 
        use v6;
 
        my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4;
 
        my $screen-width         = 30;
 
        my $label-area-width = 1 + [max] @scoresE<raquo>.keyE<raquo>.chars;
        my $max-score            = [max] @scoresE<raquo>.value;
        my $unit                 = ($screen-width - $label-area-width) / $max-score;
 
        for @scores {
           my $format = '%- ' ~ $label-area-width ~ "s%s\n";
           printf $format, .key, 'X' x ($unit * .value);
        }
 
=end code

На экран будет выведен следующий результат:
 
=begin output
 
        Ana         XXXXXXXXXXXXXXXXXXXXXX
        Dave        XXXXXXXXXXXXXXXX
        Charlie     XXXXXXXXXXX
        Beth        XXXXXXXXXXX
 
=end output

Строка в примере:

=begin code
 
        my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4;
 
=end code

... содержит три разных оператора: C<=>, C<< => >>, и C<< , >>.

Оператор C<=>  является I<X<оператором присваивания|оператор, присваивание; оператор;=;присваивание > >. Он  берет значения, расположенные справа, и сохраняет их в переменной слева, а именно в переменной C<@scores>.
 
=begin para :sidebar

Как и в других языках, основанных на синтаксисе C, Perl 6 допускает сокращенные формы для записи обычных присвоений. То есть вместо  C<< $var = $var op EXPR >>
использовать   C<< $var op= EXPR >>.   Например, C<~> (тильда) - оператор строковой конкатенации (объединения); для добавления текста к концу строки достаточно выражения C<$string ~= "text">, которое является эквивалентом C<$string = $string ~ "text">.

=end para

Оператор  C<< => >> ( => - I<толстая стрелка> X<|пара;оператор,толстая стрелка >) создает C<Пару> ( pair ) объектов. Пара содержит один ключ и одно значение; ключ располагается слева от оператора  C<< => >>, а значение - справа. Этот оператор имеет одну особенность: парсер интерпретирует любой идентификатор в левой части выражения как строку. С учетом этой особенности строку из примера можно записать следующим образом:

=begin code
 
        my @scores = Ana => 8, Dave => 6, Charlie => 4, Beth => 4;
 
=end code

И наконец,  оператор C<,>  создает C<Парселы> ( C<Parcel> ) - последовательности объектов. В данном случае объектами являются пары.

Все три рассмотренные оператора являются I< X<инфиксными|инфикс;infix;оператор;оператор, инфиксный>>, то есть располагаются между двумя I<X<термами|терм>> (terms). Термом может быть литерал, например C<8> или C<"Dave">,  или комбинация других термов и операторов.

В предыдущей главе были использованы также другие типы операторов. Они сдержали инструкцию  C<%games{$p1}++;>. I< X<Постциркумфиксный|postcircumfix;оператор,postcircumfix;оператор, постфиксный>> (postcircumfix) оператор C<{...}> указан после ( I<post>) терма, и содержит два символа ( открывающую и закрывающую фигурные скобки),  которые окружают (I<circumfix>) другой терм. После postcircumfix оператора следует обычный I<постфиксный> оператор C<++>, который инкрементирует (увеличивает на единицу) переменную слева. Не допускается использование пробела между термом и его постфиксными (postfix) или постциркумфиксным (postcircumfix ) операторами.

Еще один тип операторов  - I<X<префиксный|оператор, префиксный;префикс>> (prefix). Они указываются перед термом. Примером такого оператора служит C<->, который инвертирует указанное числовое значение: C<my $x = -4>. 

Оператор C<-> еще означает вычитание, поэтому C<say 5 - 4> напечатает C<1>. Чтобы отличить префиксный оператор C<-> от инфиксного C<->, парсер Perl 6 отслеживает контекст: ожидается ли в данный момент инфиксный оператор или терм. У терма может отсутствовать или указано сколько угодно префиксных операторов, то есть возможна  следующее выражение : C<< say 4 + -5 >>.  В нем, после C<+> ( инфиксного оператора ), компилятор ожидает терм, и поэтому следующий за ним C<-> интерпретируется как префиксный оператор для терма C<5>.

Следующая строка содержит новые особенности :

=begin code

        my $label-area-width = 1 + [max] @scoresE<raquo>.keyE<raquo>.chars;

=end code

Начинатся указанная строка с безобидного определения переменной C<my $label-area-width> и оператора присвоения. Затем следует простое операция сложения C<1 + ...>. Правая часть оператора C<+> более сложная.
X<|оператор, max>
Инфиксный оператор C<max> возвращает большее из двух значений, то есть C<2 max 3> вернет 3. Квадратные скобки вокруг оператора дают инструкцию Perl 6 применить указанный в них оператор к списку поэлементно. Поэтому  конструкция C<[max] 1, 5, 3, 7>  эквивалентна C<1 max 5 max 3 max 7>, а результатом будет число C<7>.

Также можно использовать C<[+]> для получения суммы элементов  списка, C<[*]> - произведения и C<< [<=] >> для проверки отсортирован ли список по убыванию.

Следующим идет выражение C<@scoresE<raquo>.keyE<raquo>.chars>. Так же, как C<@variable.method> вызывает метод у C<@variable>, C<< @arrayE<raquo>.method >> производит вызовы метода для каждого элемента в массиве C<@array> и возвращает список результатов.


C< E<raquo> > представляет собой I<X< гипер опрератор>>. Это также Unicode символ. В случае невозможности ввода данного символа, его можно заменить на два знака больше   (C<<< >> >>>) . За неимением Ubuntu под рукой следующее решение привожу в оригинале: I<Ubuntu 10.4: In
System/Preferences/Keyboard/Layouts/Options/Compose Key position select one of
the keys to be the "Compose" key. Then press Compose-key and the "greater than"
key twice.>

Результатом C<< @scoresE<raquo>.key >> является список ключей пар в C<@scores>, а C<< @scoresE<raquo>.keyE<raquo>.chars >>  возвращает список  длин ключей в C<@scores>.

Выражение  C< [max]@scoresE<raquo>.keyE<raquo>.chars > выдаст наибольшее из значений. Это так же идентично следующему коду:

=begin code
        @scores[0].key.chars
           max @scores[1].key.chars
           max @scores[2].key.chars
           max ...

=end code

Предваряющие выражение I<(circumfix)> квадратные скобки являются I<X<редукционным мета опрератором|мета опрератор,редукционный;мета оператор, []>>, который преобразует содержащийся в нем инфиксный оператор  в оператор, который ожидает список (I<listop>), а также последовательно осуществляет операции между элементами каждого из списков.

Для отображения имен игроков и столбцов диаграммы, программе необходима информация о  количестве позиций на экране, отводимом для имен игроков. Для этого вычисляется максимальная длина имени и прибавляется 1 для отделения имени от начала  столбца диаграммы. Полученный результат будет длиной подписи к столбцу диаграммы (I<с одним уточнением: столбцы - горизотальные  >).

Следующий текст определяет наибольшее количество очков:

=begin code
        my $max-score = [max] @scoresE<raquo>.value;
=end code

Область диаграммы имеет ширину C<$screen-width - $label-area-width>, равную разнице ширины экрана и длины подписи для данного столбца.  Таким образом для каждой строки рейтинга потребуется вывести на экран :

=begin code
        my $unit = ($screen-width - $label-area-width) / $max-score;
=end code

... количество символов C<X>. В процессе вычислений используются инфиксные операторы  C<-> и C</>.

Теперь вся необходимая информация известна и можно построить диаграмму:

=begin code
        for @scores {
           my $format = '%- ' ~ $label-area-width ~ "s%s\n";
           printf $format, .key, 'X' x ($unit * .value);
        }
=end code

Данный код циклически обходит весь список  C<@scores>, связывая  каждый из элементов со специальной переменной C<$_>. Для каждого элемента используется встроенная функция C<printf> X<|printf>, которая печатает на экране имя игрока и строку диаграммы. 

Данная функция похожа на C<printf> в языках C и Perl 5. Она получает строку форматирования, которая описывает каким образом печатать следующие за ней параметры. Если C<$label-area-width> равна 8, то  строка форматирования будет  C<"%-8s%s\n">. Это значит, что строка C<%s> занимает 8 позиций (C<'8'>) и выравнена по левому краю, за ней следует еще строка и символ новой строки C<'\n'>.
В нашем случае первой строкой является имя игрока.  второй - строка диаграммы.

Инфиксный оператор C<x>, или I<X<оператор повторения| оператор,x; оператор повторения>>, формирует строку столбца. Он возвращает строку, состоящую из левого операнда, повторенного число раз, заданное правым операндом. То есть C<'ab' x 3> вернет строку C<'ababab'>. C<.value> возвращает значение текущей пары,  C<($unit * .value)> умножает его на C<$unit>, и C<'X' x ($unit * .value)> возвращает строку с требуемым количеством символов.

=head1 Приоритетность 

X<|приоритетность операторов; приоритетность>

Объяснения примера в данной главе содержат важный момент, который не полностью  очевиден. В следующей строке:

=code
        my @scores = 'Ana' => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4;

.. в правой части присваивания определен список ( согласно оператору C<,>), состоящий из пар ( благодаря C<< => >> ), а затем присваивается переменной-массиву.  Глядя на данное выражение вполне можно придумать другие способы интерпретации. Например Perl 5 интерпретирует как :


=for code
  (my @scores = 'Ana') => 8, 'Dave' => 6, 'Charlie' => 4, 'Beth' => 4;

... так что в  C<@scores> будет содержаться только один элемент. А остальная часть выражения  воспринимается  как список констант и будет отброшена.

I<X<Правила приоритетности| приоритетность, правила>>  определяют способ обработки строки парсером. Правила приоритета в Perl 6 гласят, что инфиксный оператор C<< => >> имеет более сильную связь с аргументами чем инфиксный оператор C<,>, который в свою очередь имеет больший приоритет чем оператор присваивания C<=>.

=for para :sidebar
На самом деле существует два оператора присваивания с разными приоритетом. Когда в правой части указан скаляр, используется I<оператор присваивания еденичного значения> с высоким приоритетом. Иначе используется I<списочный оператор присваивания>, который имеет меньший приоритет.  Это позволяет следующим выражениям C<$a = 1, $b = 2> и C<@a = 1, 2>  означать ожидаемое от них: присвоение значений двум переменным в списке и присвоение списка из двух значений одной переменной.

Правила приоритетов в Perl 6 позволяют сформулировать много обычных операций в естественном виде, не заботясь о их приоритетности. Однако если требуется изменить приоритет обработки, то достаточно взять в скобки выражение и данная группа получить наиболее высокий приоритет:

=begin code
        say 5 - 7 / 2;          # 5 - 3.5  = 1.5
        say (5 - 7) / 2;        # (-2) / 2 =  -1
=end code

В приведенной ниже таблице приоритет убывает сверху вниз.

=begin table :caption("Таблица приоритетов")

 Пример                Имя
 _________________|__________________
    C<(), 42.5>         term
    C<42.rand>     вызовы методов и postcircumfixes
    C<$x++>         автоинкремент и автодекремент
    C<$x**2>        возведение в степень
    C<?$x, !$x>     логический префикс
    C<+$x, ~$x>     префиксные операторы контекстов
    C<2*3, 7/5>      мультипликативные инфиксные операторы
    C<1+2, 7-5>     инфиксные операторы сложения
    C<$x x 3>       оператор репликации (повторитель)
    C<$x ~ ".\n">   строковая конкатенация
    C<1&2>          коньктивный AND (оператор объединения)
    C<1E<VERTICAL LINE>2>      коньктивный OR (оператор объединения)
    C<abs $x>       именованный унарный префикс
    C<$x cmp 3>      non-chaining binary operators
    C<$x == 3>      chaining binary operators
    C<$x && $y>     бинарный логический инфикс AND 
    C<$x E<VERTICAL LINE>E<VERTICAL LINE> $y>     бинарный логический инфикс OR
    C<< $x > 0 ?? 1 !! -1 >>   оператор условия
    C<$x = 1>       присванивание
    C<not $x>       унарный префикс отрицания 
    C<1, 2>         запятая
    C<1, 2 Z @a>    инфиксный список
    C<@a = 1, 2>    префиксный список, присваивание списка
    C<$x and say "Yes">     инфикс AND с низким приоритетом
    C<$x or die "No">       инфикс OR с низким приритетом
    C<;>            завершние выражения
=end table


=head1 Сравнения и "Умное" сопоставление


X<|тождественность значений;===; оператор, ===>

Есть несколько способов сравнения объектов в Perl. Можно проверить равенство значений используя инфиксный оператор C<===>. Для неизменных (I<immutable>) объектов ( значения которых нельзя изменить, литералов. Например литерал C<7> всегда будет C<7>) это обычное сравнение значений. Например C<'hello'==='hello'>  всегда верно потому, что обе строки неизменны и имеют одинаковое значение.

Для изменяемых объектов C<===> сравнивает их идентичность. C<===> возвращает истину, если его аргументы являются псевдонимами одного и того же объекта. Или же двое объектов идентичны, если это  один и тот же объект. Даже если оба массива C<@a> и C<@b> I<содержат> одинаковые значения, если их контейнеры разные объекты, они будут иметь различные идентичности и I<не> будут тождественны при сравнении C<===>:

=begin code

        my @a = 1, 2, 3;
        my @b = 1, 2, 3;

        say @a  === @a;        # 1
        say @a  === @b;        # 0

        # здесь используется идентичность 
        say 3   === 3;         # 1
        say 'a' === 'a';   # 1

        my $a = 'a';
        say $a === 'a';         # 1

=end code

Оператор C<eqv> возвращает C<Истина> если два объекта одного типа I<и> одинаковой структуры. Так для C<@a> и C<@b> указанных в примере, C<@a eqv @b> истинно потому, что C<@a> и C<@b> содержат одни и те же значения. С другой стороны C<'2' eqv 2> вернет C<False>,  так как аргумент слева строка, а справа - число, и таким образом они разных типов.

=head2 Сравнения чисел

Вы можете узнать, равны ли числовые значения двух объектов  с помощью инфиксного оператора C<==>. Если один из объектов не числовой, Perl произведет его преобразование в число перед сравнением. Если не будет подходящего способа преобразовать объект в число, Perl будет использовать C<0> в качестве значения.


=begin code

        say 1 == 1.0;          # 1
        say 1 == '1';          # 1
        say 1 == '2';          # 0
        say 3 == '3b'          # 1

=end code

=begin comment
X<<| < >>
X<<| оператор,< >>
X<<| <= >>
X<<| оператор,<= >>
X<<| >= >>
X<<| оператор,>= >>
X<<| > >>
X<<| оператор;> >>
X<|!;оператор, !>
=end comment

Операторы  C<< < >>, C<< <= >>, C<< >= >>, и C<< > >>  - являются числовыми операторами сравнения и возвращают логическое значение сравнения. C<!=> возвращает C<True> I<(Истина)>, если числовые значения объектов различны.

Если сравниваются списки или массивы,то вычисляется количество элементов в списке.
=begin code

        my @colors = <red blue green>;

        if @colors == 3 {
           say "It's true, @colors contains 3 items";
        }

=end code

=head2 Сравнение строк

X<|eq;operator, eq>

Так же как C<==> преобразует свои аргументы в числа, инфиксный оператор C<eq> сравнивает равенство строк, преобразуя аргументы в строки при необходимости.

=begin code

        if $greeting eq 'hello' {
           say 'welcome';
        }

=end code

Другие операторы сравнивают строки лексикографически.

=begin table :caption("Операторы и сравнения")
 Числовые                Строковые          Значение
 _________________|______________________|______________________________
    ==              eq                  равно I<(equals)>
    !=              ne                  не равно I<(not equal)>
    !==             !eq                 не равно I<(not equal)>
    E<lt>               lt              меньше чем I<( less than )>
    E<lt>=            le                 меньше или равно I<(less or equal)>
    E<gt>             gt                 больше чем I<( greater than )>
    C<< >= >>             ge             больше или равно I<( greater or equal )>

=end table

Например,  C<'a' lt 'b'> вернет истину, так же как  C<'a' lt 'aa'>.

X<|оператор, !=;!=>
X<|ne;оператор, ne>
X<|eq;оператор,eq>

C<!=> на самом деле более удобная форма для C<!==>, который в свою очередь представляет собой объединеие метаоператора C<!> и инфиксного  оператора C<==>. Такое же обяснение приминительно к C<ne> и C<!eq>.

=head2 Three-way сравнение

X<|оператор,leg;leg>
X<|cmp;оператор,cmp>
=for comment
X<<| оператор, <=>; <=> >>

Операторы three-way сравнения получают два операнда и возвращают C<Order::Increase>, если операнд слева меньше, C<Order::Same> - если равны,  C<Order::Decrease> - если операнд справа меньше (C<Order::Increase>, C<Order::Same> и C<Order::Decrease> являются перечислениями  I<( enums )>; см. L<подтипы>). Для числовых сравнений используется оператор  C<< <=> >>, а для строковых это C<leg> (от англ.  I<l>esser, I<e>qual, I<g>reater). Инфиксный оператор C<cmp> также является оператором сравнения, возвращающий три результата сравнения. Его особенность в том, что он зависит от типа аргументов: числа сравнивает как C<< <=> >>, строки как C<leg> и ( например) пары сначала сравнивая ключи, а затем значения (если ключи равны).

=begin code
        say 10   <=> 5;           # +1
        say 10   leg 5;           # because '1' lt '5'
        say 'ab' leg 'a';         # +1, lexicographic comparison

=end code

X<|.sort>

Типичным применением упомянутых three-way операторов сравнения является сортировка.  Метод  C<.sort> в списках получает блок или функцию, которые сравнивают свои два аргумента и возвращают значения отрицательные если меньше, 0 - если аргументы равны и больше 0, если первый аргумент больше второго. Эти результаты затем используются при сортировке для формирования результата.

=begin code

        say ~<abstract Concrete>.sort;
        # output: Concrete abstract

        say ~<abstract Concrete>.sort:
               -> $a, $b { uc($a) leg uc($b) };
        # output: abstract Concrete

=end code

По умолчанию используется сортировка чувствительная к регистру, т.е. символы в верхнем регистре "больше" символов в нижем. В примере используется сортировка без учета регистра.

=head2 "Умное" сопоставление

X<|smart match; умное сопоставление; ~~>

Разные операторы сравнения приводит свои аргументы к определённым типам перед сравнением их. Это полезно, когда требуется конкретное сравнение, но типы параметров неизвестны. Perl 6 предоставляет особый оператор который позволяет производить сравнение "Делай Как Надо"  I<(Do The Right Thing )> с помощью C<~~> - оператора "умного" сравнения.

=begin code

        if $pints-drunk ~~ 8 {
           say "Go home, you've had enough!";
        }

        if $country ~~ 'Sweden' {
           say "Meatballs with lingonberries and potato moose, please."
        }

        unless $group-size ~~ 2..4 {
           say "You must have between 2 and 4 people to book this tour.";
        }

=end code

Оператор "умного" сопоставления всегда решает какого рода сравнение производить в зависимости от типа значения в правой части. В предыдущих примерах эти сравнения были числовым, строковым и сравнением диапазонов соответственно. В данной главе была продемонстрирована работа операторов сравнения: чисел - C<==> и строк C<eq>.Однако нет оператора для сравнения диапазонов. Это является частью возможностей "умного" сопоставления: более сложные типы позволяют реализовывать необычные идеи сочетая сравнения их с другими.

=begin para :sidebar

"Умное" сопоставление работает, вызывая метод C<ACCEPTS> у правого операнда и передавая ему операнд слева как аргумент. Выражение C<$answer ~~ 42> сводится к вызову C<42.ACCEPTS($answer)>. Данная информация пригодится, когда вы прочитаете последующие главы, посвященные классам и методам.  Вы тоже напишите вещи, которые смогут производить "умное" сопоставление, реализовав метод C<ACCEPTS> для того, чтобы "работало как надо".

=end para

=end pod

