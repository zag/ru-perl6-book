=begin pod
=CHAPTER Классы и Объекты 

Следующая программа показывает как может выглядеть обработчик 
зависимостей в Perl 6. Она демонстрирует использоание ползовательских
конструкторов, приватных и публичных атрибутов, методов а также 
некоторые аспекты сигнатур. Кода в примере приведено не много,
тем не менее он интересен и местами полезен.    

=begin code 

    class Task {
        has      &!callback;
        has Task @!dependencies;
        has Bool $.done;

        method new(&callback, Task *@dependencies) {
            return self.bless(*, :&callback, :@dependencies);
        }

        method add-dependency(Task $dependency) {
            push @!dependencies, $dependency;
        }

        method perform() {
            unless $!done {
                .perform() for @!dependencies;
                &!callback();
                $!done = True;
            }
        }
    }

    my $eat =
        Task.new({ say 'eating dinner. NOM!' },
            Task.new({ say 'making dinner' },
                Task.new({ say 'buying food' },
                    Task.new({ say 'making some money' }),
                    Task.new({ say 'going to the store' })
                ),
                Task.new({ say 'cleaning kitchen' })
            )
        );

    $eat.perform();

=end code 

=head1 Приступая к изучению классов

X<|class>
X<|classes>

X<|state>
X<|has>
X<|classes, has>
X<|behavior>
X<|classes, behavior>

Perl 6,как и много других языков, использует клюевое слово C<class> для определения нового класса. Следующий затем блок, как и любой другой блок, может содержать произвольный код, однако классы обычно содержат определения состояний и поведений.

Код примера содержит атрибуты (состояния), определяемые с помощью ключевого слова C<has>, и поведения, определяемые с помощью C<method>.


X<|type object>
X<|defined>
X<|.defined>

Определение класса создает I<объект-тип>, который по умолчанию становиться
доступным внути текущего пакета ( аналогично переменным, определенным с 
помощью C<our> ). Этот объект-тип является "пустым экземпляром" класса.
С ними мы встречались в предидущих главах. Например, каждый из типов C<Int>
и C<Str> относятся к объектам-типам одного из встроенных в Perl 6 классов.
Код примера в начале главы демонстрирует, как имя класса C<Task> может 
использоватья в роли ссылки в дальнейшем, например для создания экземпляров класса вызывая метод C<new>.

Объекты-типы неопределены в том смысле, что они возвращают значение C<False>
если вызвать их метод C<.defined>. Эту особенность можно использвать чтобы узнать является ли какой-либо объект объектом-типом или нет:

=begin code 

    my $obj = Int;
    if $obj.defined {
        say "Ordinary, defined object";
    } else {
        say "Type object";
    }

=end code

=head1 Могу ли я обладать состоянием?

X<|attributes>
X<|classes, attributes>

X<|encapsulation>
X<|classes, encapsulation>

В примере, первые три строки в блоке класса:

        has      &!callback;
        has Task @!dependencies;
        has Bool $.done;

определяют атрибуты ( в других языках они могут называться I<полями> 
или I<хранилищем экземпляра>). Атрибуты действительно являются 
индивидульным местом храниения данных для каждого созданного объекта.
Так же как переменные созданные с помощью C<my> не могут быть доступны 
извне области их видимости так и атрибуты объектов доступны только 
внутри класса. Данная особенность является основой объекто-ориентированного проектирования и назывется I<инкапсуляцией>.

Первая строка среди атрибутов определяет память для хранения callback 
-- небольшого куска кода. Он будет вызван для выполнения задачи, котороую представляет экземпляр класса C<Task>.

=begin code 

    has &!callback;

=end code
X<|sigils, ampersand>
X<|twigils>
X<|twigils, !>

Сигил C<&> указывает? что аттрибут представляет собой нечно вызываемое I<(invocable)>. Символ C<!> является твигилом I<(twigil)>, или выражаясь иначе -  вторым сигилом. Твигил является частью имени переменной. В данном случае твигил C<!> подчеркивает что данный атрибут является приватным I<(собсвенным, private)>, то есть недоступен вне класса.

Определение второго атрибута класса C<Task> также содержит приватный твигил:

=begin code

    has Task @!dependencies;

=end code

Однако этот атрибут представляет собой массив элементов и поэтому необходим
сигил C<@>. Каждый из элементов представляет собой задачу, а все вместе 
очередность задач, которая является условием завершения текущей. Кроме 
того тип атрибута сообщает, что элементы массива могут быть только
экземплярами класса C<Task> ( или класса, производного от него ).

Третий атрибут хранит статус готовности задачи:

=begin code

    has Bool $.done;

=end code

X<|twigils, .>
X<|twigils, accessors>
X<|accessor methods>
X<|classes, accessors>

Этот скалярный атрибут ( сигил C<$> ) имеет тип C<Bool>. Вместо твигила C<!>
используется твигил C<.>. В то время как инкапсуляция атрибутов является в 
Perl 6 полноценной, язык позволяет избавиться от необходимости явно создавать методы доступа к атрибутам из вне I<(accessor methods)>. Замена C<!> на
C<.> помимо определения атрибута C<$!done> определит метод доступа C<done>.
То есть результат будет тот же, как если вы написали бы следующий код:

=begin code 

    has Bool $!done;
    method done() { return $!done }

=end code

Обратите внимание, что это отличается от определения публичного атрибута,
как это позволяют некоторые языки: и вы действительно получаете  недоступную
снаружи переменную и метод, без необходимости писать этот метод вручную I<(просто заменив C<!> на C<.>)>. Подобный способ хорош пока вам не понадобится более сложные действия, чем просто возврат значения.

Стоит заметить что твигил C<.> создает метод с доступом к атрибуту только в режиме чтения. Чтобы пользователи этого объекта могли сбросить статус готовности задачи (для выполнения ее например повторнао) можно изменить  определение атрибута на следующее:

=begin code 

    has Bool $.done is rw;

=end code

X<traits, is rw>

The C<is rw> trait causes the generated accessor method to return something
external code can modify to change the value of the attribute.

=head1 Methods

X<|methods>
X<|classes, methods>

While attributes give objects state, methods give objects behaviors.  Ignore
the C<new> method temporarily; it's a special type of method.  Consider the
second method, C<add-dependency>, which adds a new task to this task's
dependency list.

=begin code

    method add-dependency(Task $dependency) {
        push @!dependencies, $dependency;
    }

=end code

X<|invocant>

In many ways, this looks a lot like a C<sub> declaration. However, there are
two important differences. First, declaring this routine as a method adds it to
the list of methods for the current class.  Thus any instance of the C<Task>
class can call this method with the C<.> method call operator.  Second, a
method places its invocant into the special variable C<self>.

The method itself takes the passed parameter--which must be an instance of the
C<Task> class--and C<push>es it onto the invocant's C<@!dependencies>
attribute.

The second method contains the main logic of the dependency handler:

=begin code

    method perform() {
        unless $!done {
            .perform() for @!dependencies;
            &!callback();
            $!done = True;
        }
    }

=end code

It takes no parameters, working instead with the object's attributes. First, it
checks if the task has already completed by checking the C<$!done> attribute.
If so, there's nothing to do.

X<|operators, .>

Otherwise, the method performs all of the task's dependencies, using the C<for>
construct to iterate over all of the items in the C<@!dependencies> attribute.
This iteration places each item--each a C<Task> object--into the topic
variable, C<$_>.  Using the C<.> method call operator without specifying an
explicit invocant uses the current topic as the invocant.  Thus the iteration
construct calls the C<.perform()> method on every C<Task> object in the
C<@!dependencies> attribute of the current invocant.

After all of the dependencies have completed, it's time to perform the current
C<Task>'s task by invoking the C<&!callback> attribute directly; this is the
purpose of the parentheses.  Finally, the method sets the C<$!done> attribute
to C<True>, so that subsequent invocations of C<perform> on this object (if this
C<Task> is a dependency of another C<Task>, for example) will not repeat the
task.

=head1 Constructors

X<|constructors>

Perl 6 is rather more liberal than many languages in the area of constructors.
A constructor is anything that returns an instance of the class.  Furthermore,
constructors are ordinary methods. You inherit a default constructor named
C<new> from the base class C<Object>, but you are free to override C<new>, as
this example does:

=begin code

    method new(&callback, Task *@dependencies) {
        return self.bless(*, :&callback, :@dependencies);
    }

=end code

X<|objects, bless>
X<|bless>

The biggest difference between constructors in Perl 6 and constructors in
languages such as C# and Java is that rather than setting up state on a somehow
already magically created object, Perl 6 constructors actually create the
object themselves. This easiest way to do this is by calling the C<bless>
method, also inherited from C<Object>. The C<bless> method expects a positional
parameter--the so-called "candidate"--and a set of named parameters providing
the initial values for each attribute.

The example's constructor turns positional arguments into named arguments, so
that the class can provide a nice constructor for its users. The first
parameter is the callback (the thing to do to execute the task). The rest of
the parameters are dependent C<Task> instances.  The constructor captures these
into the C<@dependencies> slurpy array and passes them as named parameters to
C<bless> (note that C<:&callback> uses the name of the variable--minus the
sigil--as the name of the parameter).

=head1 Consuming our class

After creating a class, you can create instances of the class.  Declaring a
custom constructor provides a simple way of declaring tasks along with their
dependencies. To create a single task with no dependencies, write:

=begin code

    my $eat = Task.new({ say 'eating dinner. NOM!' });

=end code

An earlier section explained that declaring the class C<Task> installed a type
object had been installed in the namespace.  This type object is a kind of
"empty instance" of the class, specifically an instance without any state.  You
can call methods on that instance, as long as they do not try to access any
state; C<new> is an example, as it creates a new object rather than modifying
or accessing an existing object.

Unfortunately, dinner never magically happens.  It has dependent tasks:

=begin code

    my $eat =
        Task.new({ say 'eating dinner. NOM!' },
            Task.new({ say 'making dinner' },
                Task.new({ say 'buying food' },
                    Task.new({ say 'making some money' }),
                    Task.new({ say 'going to the store' })
                ),
                Task.new({ say 'cleaning kitchen' })
            )
        );

=end code

Notice how the custom constructor and sensible use of whitespace allows a
layout which makes task dependencies clear.

Finally, the C<perform> method call recursively calls the C<perform> method on
the various other dependencies in order, giving the output:

    making some money
    going to the store
    buying food
    cleaning kitchen
    making dinner
    eating dinner. NOM!

=head1 Inheritance

Object Oriented Programming provides the concept of inheritance as one of the 
mechanisms to allow for code reuse.  Perl 6 supports the ability for one class 
to inherit from one or more classes.  When a class inherits from another class
that informs the method dispatcher to follow the inheritance chain to look
for a method to dispatch.  This happens both for standard methods defined via
the method keyword and for methods generated through other means such as 
attribute accessors.

=begin code

    class Employee {
        has $.salary;

        method pay() {
            say "Here is \$$.salary";
        }

    }

    class Programmer is Employee {
        has @.known_languages is rw;
        has $.favorite_editor;

        method code_to_solve( $problem ) {
            say "Solving $problem using $.favorite_editor in " 
            ~ $.known_languages[0] ~ '.';
        }
    }

=end code

Now any object of type Programmer can make use of the methods and accessors 
defined in the Employee class as though they were from the Programmer class.

=begin code

    my $programmer = Programmer.new(
        salary => 100_000, 
        known_languages => <Perl5 Perl6 Erlang C++>,
        favorite_edtor => 'vim'
    );

    $programmer.code_to_solve('halting problem');
    $programmer.pay();

=end code

=head2 Overriding Inherited Methods

Of course, classes can override methods and attributes defined on ancestoral 
classes by defining their own.  The example below demonstrates the Baker class 
overriding the Cook's cook method.

=begin code

    class Cook is Employee {
        has @.utensils  is rw;
        has @.cookbooks is rw;

        method cook( $food ) {
            say "Cooking $food";
        }

        method clean_utensils {
            say "Cleaning $_" for @.utensils;
        }
    }

    class Baker is Cook {
        method cook( $confection ) {
            say "Baking a tasty $confection";
        }
    }

    my $cook = Cook.new( 
        utensils => (<spoon ladel knife pan>), 
        cookbooks => ('The Joy of Cooking'), 
        salary => 40000);

    $cook.cook( 'pizza' ); # Cooking pizza

    my $baker = Baker.new(
        utensils => ('self cleaning oven'), 
        cookbooks => ("The Baker's Apprentice"), 
        salary => 50000);

    $baker.cook('brioche'); # Baking a tasty brioche

=end code

Because the dispatcher will see the cook method on Baker before it moves up to 
the parent class the Baker's cook method will be called.

=head2 Multiple Inheritance

As mentioned before, a class can inherit from multiple classes.  When a class 
inherits from multiple classes the dispatcher knows to look at both classes when
looking up a method to search for.  As a side note, Perl 6  uses the C3 
algorithm to linearize the multiple inheritance hierarchies, which is a 
significant improvement over Perl 5's approach to handling multiple inheritance.

=begin code

    class GeekCook is Programmer is Cook {
        method new( *%params ) {
            push( %params<cookbooks>, "Cooking for Geeks" );
            return self.bless(%params);
        }
    }

    my $geek = GeekCook.new( 
        books           => ('Learning Perl 6'), 
        utensils        => ('blingless pot', 'knife', 'calibrated oven'),
        favorite_editor => 'MacVim',
        known_languages => <Perl6>
    );

    $geek.cook('pizza');
    $geek.code_to_solve('P =? NP');

=end code

Now all the methods made available by both the Programmer class and the Cook
class are available from the GeekCook class.

While multiple inheritance is a useful concept to know and on occasion use, it
is important to understand that there are more useful OOP concepts.  When
reaching for multiple inheritance it is good practice to consider whether the
design wouldn't be better realized by using roles.  For more information on roles
check out the Roles chapter.

=head1 Introspection

Introspection is the process of gathering information about some objects in
your program, not by reading the source code, but by querying the object (or a
controlling object) for some properties, like its type.

Given an object C<$p>, and the class definitions from the previous sections,
we can ask it a few questions:

=begin code

    if $o ~~ Employee { say "It's an employee" };
    if $o ~~ GeekCook { say "It's a geeky cook" };
    say $o.WHAT;
    say $o.perl;
    say $o.^methods(:local).join(', ');

=end code

The output can look like this:

=begin code

    It's an employee
    Programmer()
    Programmer.new(known_languages => ["Perl", "Python", "Pascal"], favorite_editor => "gvim", salary => "too small")
    code_to_solve, known_languages, favorite_editor

=end code

The first two tests each smart-match against a class name. If the object is
of that class, or of an inheriting class, it returns true. So the object in
question is of class C<Employee> or one that inherits from it, but not
C<GeekCook>.

The C<.WHAT> method returns the type object associated with the object C<$o>,
which tells the exact type of C<$o>: in this case C<Programmer>.

C<$o.perl> returns a string that can be executed as Perl code, and reproduces
the original object C<$o>. While this does not work perfectly in all
casesN<for example closures cannot easily be reproduced this way; if you don't
know what a closure is don't worry. Also current implementations have problems
with dumping cyclic data structures this way, but they are expected to be
handlded correctly by C<.perl> at some point.>, it
is very useful for debugging simple objects.

Finally C<$o.^methods(:local)> produces a list of methods that can be called
on C<$o>. The C<:local> named argument limits the returned methods to those
defined in the C<Employee> class, and excludes the inherited methods.

The syntax of calling method with C<.^> instead of a single dot means that it
is actually a method call on the I<meta class>, which is  a class managing the
properties of the C<Employee> class - or any other class you are interested
in. This meta class enables other ways of introspection too:

=begin code

    say $o.^attributes.join(', ');
    say $o.^parents.join(', ');  

=end code

Introspection is very useful for debugging, and for learning the language
and new libraries. When a function or method
returns an object you don't know about, finding its type with C<.WHAT>, a
construction recipe for it with C<.perl> and so on you'll get a good idea what
this return value is. With C<.^methods> you can learn what you can do with it.

But there are other applications too: a routine that serializes objects to a
bunch of bytes needs to know the attributes of that object, which it can find
out via introspection.

=head1 Exercises

B<1.> The method C<add-dependency> in C<Task> permits the creation of I<cycles>
in the dependency graph.  That is, if you follow dependencies, you can
eventually return to the original C<Task>. Show how to create a graph with
cycles and explain why the C<perform> method of a C<Task> whose dependencies
contain a cycle would never terminate successfully.

B<Answer:> You can create two tasks, and then "short-circuit" them with
C<add-dependency>:

=begin code

    my $a = Task.new({ say 'A' });
    my $b = Task.new({ say 'B' }, $a);
    $a.add-dependency($b);

=end code

The C<perform> method will never terminate because the first thing the method
does is to call all the C<perform> methods of its dependencies. Because C<$a>
and C<$b> are dependencies of each other, none of them would ever get around to
calling their callbacks. The program will exhaust memory before it ever prints
C<'A'> or C<'B'>.

B<2.> Is there a way to detect the presence of a cycle during the course of a
C<perform> call? Is there a way to prevent cycles from ever forming through
C<add-dependency>?

B<Answer:> To detect the presence of a cycle during a C<perform> call, keep
track of which C<Task>s have started; prevent a C<Task> from starting twice
before finishing:

=begin code

    augment class Task {
        has Bool $!started = False;

        method perform() {
            if $!started++ && !$!done {
                die "Cycle detected, aborting";
            }

            unless $!done {
                .perform() for @!dependencies;
                &!callback();
                $!done = True;
            }
        }
    }

=end code

Another approach is to stop cycles from forming during C<add-dependency> by
checking whether there's already a dependency running in the other direction.
(This is the only situation in which a cycle can occur.)  This requires the
addition of a helper method C<depends-on>, which checks whether a task depends
on another one, either directly or transitively. Note the use of C<б╩> and
C<[||]> to write succinctly what would otherwise have involved looping over all
the dependencies of the C<Task>:

=begin code

    augment class Task {
        method depends-on(Task $some-task) {
            $some-task === any(@!dependencies)
            [||] @!dependenciesб╩.depends-on($some-task)
        }

        method add-dependency(Task $dependency) {
            if $dependency.depends-on(self) {
                warn 'Cannot add that task, since it would introduce a cycle.';
                return;
            }
            push @!dependencies, $dependency;
        }
    }

=end code

B<3.> How could C<Task> objects execute their dependencies in parallel? (Think
especially about how to avoid collisions in "diamond dependencies", where a
C<Task> has two different dependencies which in turn have the same dependency.)

B<Answer:> Enabling parallelism is easy; change the line C<.perform() for
@!dependencies;> into C<@!dependenciesб╩.perform()>. However, there may be race
conditions in the case of diamond dependencies, wherein C<Task>s C<A> starts
C<B> and C<C> in parallel, and both start a copy of C<D>, making C<D> run
twice. The solution to this is the same as with the cycle-detection in Question
2: introducing an attribute C<$!started>. Note that it's impolite to die if a
C<Task> has started but not yet finished, because this time it might be due to
parallelism rather than cycles:

=begin code

    augment class Task {
        has Bool $!started = False;

        method perform() {
            unless $!started++ {
                @!dependenciesб╩.perform();
                &!callback();
                $!done = True;
            }
        }
    }

=end code

=end pod

