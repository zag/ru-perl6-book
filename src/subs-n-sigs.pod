=begin pod
=NAME Подпрограммы и сигнатуры

X<|подпрограмма;аргументы;сигнатура;возвращаемое значение>

I<Подпрограмма> представляет собой участок кода, выполняющий определенную задачу. Она может оперировать передаваемыми ей при вызове данными I(аргументами) и может производить результаты I(возвращаемые значения). I<Сигнатурой> подпрограммы является описание всех передаваемых при вызове аргументов и любых возвращаемых значений.

Первая глава демонстрирует простые подпрограммы. Операторы, описанные во второй главе, являются подпрограммами, которые Perl 6 обрабатывает необычным способом. Однако, они будут описаны поверхностно насколько это возможно.

=head1 Определение подпрограмм

X<|подпрограммы, определение>

Определение подпрограммы состоит из нескольких частей. Сперва следует декларатор C<sub>, указывающий начало определения подпрограммы. Затем - необязательное имя и необязательная сигнатура. И наконец - тело попрограммы: ограниченный фигурными скобками блок кода. Этот код выполняется каждый раз при вызове подпрограммы.

К примеру, в коде:

=begin code

    sub panic() {
        say "Oh no! Something has gone most terribly wrong!";
    }

=end code

... определена попрограмма с именем C<panic>. Ее сигнатура отсутствует, а тело состоит их единственного оператора C<say>.

X<|область видимости, подпрограммы; подпрограммы, область видимости>

По умолчанию, подпрограммы ограничена областью лексической видимости, как и любая переменная объявленная с помощью C<my>. Это подразумевает, что подпрограмма может быть вызвана, только в границах той области видимости I( Как правило это блок кода ), внутри которой она была определена. Чтобы подпрограмма стала доступной внутри всего пакета используется декларатор I<(ключевое слово)> C<our>:

=begin code
    {
        our sub eat() {
            say "om nom nom";
        }

        sub drink() {
            say "glug glug";
        }
    }

    eat();    # om nom nom
    drink();  # fails, can't drink outside of the block
=end code

C<our> также делает подпрограмму видимой вне пакета или модуля:

=begin code
    module EatAndDrink {
         our sub eat() {
             say "om nom nom";
         }

         sub drink() {
             say "glug glug";
         }
    }
    EatAndDrink::eat();    # om nom nom
    EatAndDrink::drink();  # fails, not declared with "our"
=end code

Чтобы подпрограмма стала доступна в другой области видимости, используется экспорт (см. I<Экспортирование>).

X<| анонимные подпрограммы; подпрограммы, анонимные; подпрограммы, первого класса>

Подпрограммы в Perl 6 представляют собой объекты. Их можно передавать и хранить в составе структур данных, а так производить те же действия, что и по отношению к другим данным. Дизайнеры языков программирования часто называют их I<подпрограммами первого класса>. Они являются такими же основополагающими для использования в языке, как и хэши или массивы.

Подпрограммы первого класса позволяют решать сложные задачи. Например, для создания небольшого ASCII рисунка с изображением танцующих фигур, возможно построение хэша, ключами которого будут названия движений в танце, а значениями - анонимные подпрограммы. Допустим, что пользователи могут вводить названия списки движений I<( возможно с коврика для танцев или другого экзотического устройства)>. Как можно организовать легко изменяемый список движений, а также возможно безопасно сделать проверку вводимых пользователем названий движений на предмет допустимых ? Возможно следующая структура программы станет отправной точкой для достижения результата:

=begin code

    my $dance = '';
    my %moves =
        hands-over-head => sub { $dance ~= '/o\ '   },
        bird-arms       => sub { $dance ~= '|/o\| ' },
        left            => sub { $dance ~= '>o '    },
        right           => sub { $dance ~= 'o< '    },
        arms-up         => sub { $dance ~= '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        %moves{$move}.();
    }

    say $dance;

=end code

На основании вывода этой программы, вы сможете убедиться что танец YMCA N< Возможно имеется в виду L<Y.M.C.A.|http://en.wikipedia.org/wiki/Y.M.C.A._%28song%29>> также плохо выглядит в ASCII виде, как и в реальной жизни.

=head1 Добавление сигнатур
X<|параметры; подпрограммы, синатуры; сигнатуры, подпрограмм>

Сигнатура подпрограммы решает две задачи. Во первых, она объявляет список обязательных и необязательных аргументов, передаваемых при вызове подпрограммы. Во вторых, с помощью сигнатуры объявляются переменные и их связь с аргументами подпрограммы. Эти переменные называются I<параметрами>. Сигнатуры в Perl 6 обладают дополнительными возможностями: они позволяют ограничивать значения аргументов, сравнивать и извлекать сложные структуры данных.

=head2 Основы

В своей простой форме сигнатура - список разделенных запятой имен переменных, с которыми связываются входные аргументы подпрограммы.

=begin code

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer('Hobgoblin', 1);    # A pint of Hobgoblin, please.
    order-beer('Zlatц+ Baе+ant', 3); # 3 pints of Zlatц+ Baе+ant, please.

=end code

Использование термина I<связываются> вместо I<присваиваются> весьма существенно. Переменные в сигнатуре являются ссылками в режиме "чтения" на передаваемые подпрограмме аргументы. Это делает недоступными для модификаций входные значения.

Связывание в режиме "только чтение" можно отменить. Если пометить параметр атрибутом C<is rw>, то передаваемое значение можно будет изменять. Эти изменения будут применены также к оригинальным данным, передаваемым при вызове подпрограммы. В случае, если будет передан литерал или другое константное значение для C<rw> параметра, то связывание завершиться ошибкой в месте вызова подпрограммы, вызвав программное исключение:

=begin code

    sub make-it-more-so($it is rw) {
        $it ~= substr($it, $it.chars - 1) x 5;
    }

    my $happy = "yay!";
    make-it-more-so($happy);
    say $happy;                # yay!!!!!!
    make-it-more-so("uh-oh");  # Fails; can't modify a constant

=end code

Также возможно создание копии передаваемых значений с помощью C<is copy>. В таком случае, данные вне подпрограммы будут защищены от модификаций, а внутри подпрограммы могут быть изменены:

=begin code

    sub say-it-one-higher($it is copy) {
        $it++;
        say $it;
    }

    my $unanswer = 41;
    say-it-one-higher($unanswer);  # 42
    say-it-one-higher(41);         # 42

=end code

Столь подробная маркировка изменяемых параметров может показать чрезмерной, но скорее всего вы не будете использовать эти модификаторы часто. В то время как некоторые языки требуют пометки параметров C<rw> для эмуляции возврата множественных результатов, Perl 6 позволяет напрямую возвращать несколько значений в ответе без подобных фокусов.

=head2 Передача массивов, хэшей и кода

Сигил переменной указывает на ее предназначение. В сигнатуре, сигил переменной ограничивает типы передаваемых аргументов. Например, сигил C<@> определяет проверку передаваемых значений на соответствие типу C<Positional> I<(Позиционный)>, который включает в себя типы наподобие C<Array> I<(массивов)> и списков. При передаче параметров нарушающих это ограничение на экран будет выведено сообщение об ошибке.

=begin code
    sub shout-them(@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    my @last_words = <do not want>;
    shout-them(@last_words);  # DO NOT WANT
    shout-them('help');       # Fails; a string is not Positional

=end code

Соответственно, сигил C<%> указывает, что ожидается нечто C<Associative> I<(Ассоциативное)>, т.е. что-то позволяющее индексирование с помощью операторов C<< <...> >> или
C<{...}>. В свою очередь сигил C<&> требует указания чего-то вызываемого, например анонимной подпрограммы. В таком случае производить вызов этого параметра можно без указания сигила C<&>:

=begin code

    sub do-it-lots(&it, $how-many-times) {
        for 1..$how-many-times {
            it();
        }
    }

    do-it-lots(sub { say "Eating a stroopwafel" }, 10);

=end code

Скаляр (сигил C<&>) не имеет ограничений. Что угодно может быть связано с ним, даже если оно может связываться с другими сигилами.

=head1 Интерполяция массивов и хэшей

Иногда требуется заполнить позиционные аргументы значениями из массива.
Вместо написания C<eat(@food[0], @food[1], @food[2], ...)> и так далее, вы можете линеаризовать I<(flatten)> его в список аргументов предварив вертикальной чертой: C<eat(|@food)>.

Кроме того, можно интерполировать хэши в именованные аргументы:

=begin code

    sub order-shrimps($count, $from) {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    my %user-preferences = ( from => 'Northern Sea' );
    order-shrimps(3, |%user-preferences)

=end code

=head2 Необязатльные параметры

Иногда аргументы могут быть необязательными. Например, достаточно других параметров с их значениями по умолчанию. В таких случаях подобные необязательные параметры можно пометить как опциональные. При вызовах таких подпрограмм появляется выбор в наборе передаваемых аргументов.

Либо присвоить значение параметра по умолчанию в сигнатуре :

=begin code

    sub order-steak($how = 'medium') {
        say "I'd like a steak, $how";
    }

    order-steak();
    order-steak('well done');

=end code

... или добавить знак вопроса к имени параметра. В последнем случае параметр получает неопределенное значение, если аргумент не передан:


=begin code

    sub order-burger($type, $side?) {
       say "I'd like a $type burger" ~
           ( defined($side) ?? " with a side of $side" !! "" );
    }

    order-burger("triple bacon", "deep fried onion rings");

=end code

=head2 Именованные параметры

Когда подпрограмма имеет много параметров, зачастую, проще привязывать параметры к имени вместо к их позиции в списке передаваемых аргументов. Как следствие, порядок следования аргументов при вызове становиться неактульным:

=begin code

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer(type => 'Hobgoblin', pints => 1);
    # A pint of Hobgoblin, please.

    order-beer(pints => 3, type => 'ZlatГ?? BaЕ??ant');
    # 3 pints of ZlatГ?? BaЕ??ant, please.

=end code

Возможно определить входной аргумент, который может быть передан только по имени, а не позиционно при вызове. Для этого перед именем параметра указывается двоеточие:

=begin code

    sub order-shrimps($count, :$from = 'North Sea') {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    order-shrimps(6);                       # takes 'North Sea'
    order-shrimps(4, from => 'Atlantic Ocean');
    order-shrimps(22, 'Mediterranean Sea'); # not allowed, :$from is named only

=end code

В отличии от позиционных параметров, именованные являются необязательными по умолчанию. Чтобы сделать именованный параметр обязательным необходимо добавить к имени параметра восклицательный знак C<!>.

=begin code

    sub design-ice-cream-mixture($base = 'Vanilla', :$name!) {
        say "Creating a new recipe named $name!"
    }

    design-ice-cream-mixture(name => 'Plain');
    design-ice-cream-mixture(base => 'Strawberry chip'); # missing $name

=end code

=head3 Переименование параметров

Так как требуется указывать имена при передаче именованных параметров, то данные имена являются частью общедоступного API подпрограмм. Выбирайте имена осторожно ! Иногда может оказаться полезным отделить имя параметра от имени переменной подпрограммы, с которой он связан:

=begin code

    sub announce-time(:dinner($supper) = '8pm') {
        say "We eat dinner at $supper";
    }

    announce-time(dinner => '9pm');      # We eat dinner at 9pm

=end code

Параметры могут иметь несколько имен ! Если часть пользователей британцы, а остальные - американцы, то можно написать:

=begin code

    sub paint-rectangle(
            :$x      =   0,
            :$y      =   0,
            :$width  = 100,
            :$height =  50,
            :color(:colour($c))) {

       # print a piece of SVG that reprents a rectangle
       say qq[<rect x="$x" y="$y" width="$width" height="$height"
                     style="fill: $c" />]
    }

    # both calls work the same
    paint-rectangle :color<Blue>;
    paint-rectangle :colour<Blue>;

    # of course you can still fill the other options
    paint-rectangle :width(30), :height(10), :colour<Blue>;

=end code

=head3 Альтернативный синтаксис Именованных параметров

Именованные параметры на самом деле являются C<Парами> ( C<Pair>, пара ключ - значение). Существует несколько способов описания C<Пар>. Отличаются они степенью наглядности, так как каждый вариант предусматривает различные механизмы оформления. Следующие три вызова эквивалентны:

=begin code

    announce-time(dinner => '9pm');
    announce-time(:dinner('9pm'));
    announce-time(:dinner<9pm>);

=end code

Если передается логическое значение, то достаточно определения ключа:

=begin code

    toggle-blender( :enabled); # enables  the blender
    toggle-blender(:!enabled); # disables the blender

=end code

Именованный параметр C<:name> без указанного значения подразумевает неявное логическое значение C<Bool::True>. Противоположная форма, C<:!name>, указывает на неявное значение C<Bool::False>.

При создании пары, ключ которой совпадает с именем переменной, возможна следующая форма:

=begin code

    my $dinner = '9pm';
    announce-dinner :$dinner;  # same as dinner => $dinner;

=end code

В следующей таблице приведены возможные формы Пар и их значения.


=begin table :caption('Формы Пар и их значения')
 Краткая форма              Полная форма               Описание
 ------------------|-------------------------------|---------
 C<< :allowed >>    C<< allowed => Bool::True >>        Логичекий флаг
 C<< :!allowed >>   C<< allowed => Bool::False >>       Логичекий флаг
 C<< :bev<tea coffee> >>    C<< bev => ('tea', 'coffee') >>     Список
 C<< :times[1, 3] >>    C<< times => [1, 3] >>          Массив
 C<< :opts{ a => 2 } >>     C<< opts => { a => 2 } >>       Хэш
 C<< :$var >>           C<< var => $var >>          Скалярная переменная
 C<< :@var >>           C<< var => @var >>          Переменная - массив
 C<< :%var >>           C<< var => %var >>          Переменная - хэш

=end table

Возможно использование любой из указанных форм в любом контексте, где возможно использование объекта C<Pair>.Например, для заполнения массива:

=begin code

    # TODO: better example
    my $black = 12;
    my %color-popularities = :$black, :blue(8),
                             red => 18, :white<0>;
    # same as
    # my %color-popularities = 
    #       black => 12,
    #       blue  => 8,
    #       red   => 18,
    #       white => 0;

=end code

И наконец, чтобы передать существующий объект C<Pair> в подпрограмму как позиционный параметр I<(не именнованный)>, необходимо либо заключить его в круглые скобки ( C<(:$thing)> ), либо использовать оператор C<< => >> с взятой в кавычки левой частью:  C<< "thing" => $thing >>.

=head3 Последовательность параметров

Когда используются в сигнатуре оба типа параметров, позиционные и именованные, то все позиционные параметры должны быть указаны перед именованными.

=begin code

    sub mix(@ingredients, :$name) { ... }    # OK
    sub notmix(:$name, @ingredients) { ... } # Error

=end code

Обязательные позиционные параметры также должны быть указаны перед опциональными I<(необязательными)> позиционными. Для именованных параметров нет подобных требований.

=head2 Slurpy параметры

X<|slurpy>

В приведенном ранее примере функция C<shout-it> ожидала массив в качестве аргумента. Это предотвращало передачу одиночного аргумента. Что бы сделать возможным передачу нескольких позиционных аргументов и даже  массивов аргументов, которые будут затем в подпрограмме выравнены I<(flatten)> в один аргумент "массив", необходимо предварить имя параметра I<slurpy> префиксом (C<*>):

=begin code

    sub shout-them(*@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    # now you can pass items
    shout-them('go');           # GO
    shout-them('go', 'home');   # GO HOME

    my @words = ('go', 'home');
    shout-them(@words);         # still works

=end code

Slurpy параметр I<( параметр с прешествующeй его имени звездочкой C<*> )> сохраняет ожидаемые позиционные параметры в массив. Кроме того, C<*%hash> захватывает N<slurp, переводиться как - хлебать> все входящие несвязанные именованные аргументы в хэш.

Slurpy массивы  и хши позволяют передавать все позиционные и именованные параметры в другом порядке:

=begin code

    sub debug-wrapper(&code, *@positional, *%named) {
        warn "Calling '&code.name()' with arguments "
             ~ "@positional.perl(), %named.perl()\n";
        code(|@positional, |%named);
        warn "... back from '&code.name()'\n";
    }

    debug-wrapper(&order-shrimps, 4, from => 'Atlantic Ocean');

=end code

=head1 Returning Results

Subroutines can also return values.  The ASCII art dancing example from earlier
in this chapter is simpler when each subroutine returns a new string:

=begin code

    my %moves =
       hands-over-head => sub { return '/o\ '   },
       bird-arms       => sub { return '|/o\| ' },
       left            => sub { return '>o '    },
       right           => sub { return 'o< '    },
       arms-up         => sub { return '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        print %moves{$move}.();
    }

    print "\n";

=end code

A Perl subroutine can return multiple values:

=begin code

    sub menu {
        if rand < 0.5 {
            return ('fish', 'white wine')
        } else {
            return ('steak', 'red wine');
        }
    }

    my ($food, $beverage) = menu();

=end code

X<|return>

If you exclude the C<return> statement, Perl will return the value produced by
the last statement run inside the subroutine.  This simplifies the previous
example:

=begin code

    sub menu {
        if rand < 0.5 {
            'fish', 'white wine'
        } else {
            'steak', 'red wine';
        }
    }

    my ($food, $beverage) = menu();

=end code

X<|return, implicit>

Be wary of relying on this: when the flow of control within a subroutine is
sufficiently complex, adding an explicit C<return> will clarify the code. As a
general rule, only the simplest subroutines benefit from implicit C<return>.

C<return> has the additional effect of immediately exiting the subroutine:

=begin code

    sub create-world(*%characteristics) {
        my $world = World.new(%characteristics);
        return $world if %characteristics<temporary>;

        save-world($world);
    }

=end code

... and you'd better not misplace your new C<$world> if it's temporary, as it's
the only one you're going to get.

=head1 Working With Types

Many subroutines cannot meaningfully work with arbitrary parameters, but
require that the parameters support certain methods or have other properties.
In these cases, it makes sense to restrict the types of parameters, such that
attempts to pass incorrect values as arguments will cause Perl to raise an
error at the time of calling the subroutine.

=head2 Basic Types

X<|constraint, type>
X<|parameter type constraint>

The easiest way to restrict the possible values that a subroutine accepts is by
writing a type name before a parameter.  For example, a subroutine that
performs numeric calculations on its parameters could require that its
arguments are of the type C<Numeric>:

=begin code

    sub mean(Numeric $a, Numeric $b) {
        return ($a + $b) / 2;
    }

    say mean 2.5, 1.5;
    say mean 'some', 'strings';

=end code

This produces the output:

=begin screen

    2
    Nominal type check failed for parameter '$a';
        expected Numeric but got Str instead

=end screen

If multiple parameters have type constraints, each argument must fulfill the
type constraint of the parameter to which it binds.

=head2 Adding Constraints

X<|constraint>
X<|where>

Sometimes a type name is insufficient to describe the requirements for an
argument. In this case, you may add an additional I<constraint> to the
parameter with a C<where> block:

=begin code

    sub circle-radius-from-area(Numeric $area where { $area >= 0 }) {
        ($area / pi).sqrt
    }

    say circle-radius-from-area(3);    # OK
    say circle-radius-from-area(-3);   # Error

=end code

Because the calculation is meaningful only for non-negative area values, the
parameter includes a constraint which returns C<True> for non-negative values.
If this constraint returns a false value, the type check will fail when
something calls this subroutine.

The block after the C<where> optional; Perl performs the check by smart
matching the argument against whatever follows the C<where>. It is possible to
accept arguments in a certain range by writing:

=begin code

    sub set-volume(Numeric $volume where 0..11) {
        say "Turning it up to $volume";
    }

=end code

To constrain arguments to those existing keys of a hash:

=begin code

    my %in-stock = 'Staropramen' => 8, 'Mori' => 5, 'La Trappe' => 9;

    sub order-beer(Str $name where %in-stock) {
        say "Here's your $name";
        %in-stock{$name}--;
        if %in-stock{$name} == 0 {
            say "OH NO! That was the last $name, folks! :'(";
            %in-stock.delete($name);
        }
    }

=end code

=head1 Captures

X<|captures>
X<|Capture>

In one sense, a signature is a collection of parameters. Captures fill the same
niche for arguments. Just as you rarely think of a signature as a
whole--instead focusing on individual parameters--you rarely have to think
about captures.  When you do, Perl 6 allows you to manipulate captures
directly.

Captures have both positional and named parts which act like lists and hashes,
respectively. The list-like parts contain positional arguments and the
hash-like parts contain named arguments.

=head2 Creating And Using A Capture

To build a capture, use the C<\(...)> syntax. Like arrays and hashes, you can
interpolate a capture into an argument by using C<|>:

=begin code

    sub act($left, $right, :$action) {
        $action($left, $right);
    }

    my @tasks = \(39, 3, action => { say $^a + $^b }),
                \(6, 7, action => { say $^a * $^b });

    for @tasks -> $task-args {
        act(|$task-args);
    }

=end code

This program creates an array of captures, each of which contains two
positional arguments and one named argument. It then iterates over the array,
making a call to C<act> with each argument set. Perl 6 allows you to specify
the arguments for a call and the call itself separately, so as to apply the
same arguments over many calls, or the same call to many sets of arguments.
The code that performs the application need not know whether any of the
arguments are named or positional.

Unlike signatures, captures work like references. Any variable mentioned in a
capture exists in the capture as a I<reference> to the variable.  Thus C<rw>
parameters still work with captures involved.

=begin code

    my $value     = 7;
    my $to-change = \($value);

    sub double($x is rw) {
        $x *= 2;
    }

    sub triple($x is rw) {
        $x *= 3;
    }

    triple(|$to-change);
    double(|$to-change);

    say $value; # 42

=end code

Perl types with both positional and named parts also show up in various other
situations. For example, regex matches have both positional and named
matches--C<Match> objects themselves are a type of capture. It's also possible
to conceive of an XML node type that is a type of capture, with named
attributes and positional children.  Binding this node to a function could use
the appropriate parameter syntax to work with various children and attributes.

=head2 Captures In Signatures

All calls build a capture on the caller side and unpack it according to the
signature on the callee sideN<An optimizing Perl 6 compiler may, of course, be
able to optimize away part or all of this process, depending on what it knows
at compilation time.>. It is also possible to write a signature that binds the
capture itself into a variable. This is especially useful for writing routines
that delegate to other routines with the same arguments.

=begin code

    sub visit-czechoslovakia(|$plan) {
        warn "Sorry, this country has been deprecated.";
        visit-slovakia(|$plan);
        visit-czech-republic(|$plan);
    }

=end code

The benefit of using this over a signature like C<:(*@pos, *%named)> is that
these both enforce some context on the arguments, which may be premature. For
example, if the caller passes two arrays, they would flatten into C<@pos>. This
means that the two nested arrays could not be recovered at the point of
delegation. A capture preserves the two array arguments, so that the final
callee's signature may determine how to bind them.

=head1 Unpacking

Sometimes you need to work with only part of an array or a hash.  You can do
that with ordinary slicing access, or you can use signature binding:

=begin code

    sub first-is-largest(@a) {
        my $first = @a.shift;
        # TODO: either explain junctions, or find a
        # concise way to write without them
        return $first >= all(@a);
    }

    # same thing:
    sub first-is-largest(@a) {
        my :($first, *@rest) := \(|@a)
        return $first >= all(@rest);
    }

=end code

The signature binding approach might seem clumsy, but when you use it in the
main signature of a subroutine, you get tremendous power:

=begin code

    sub first-is-largest([$first, *@rest]) {
        return $first >= all(@rest);
    }

=end code

X<|unpacking>
X<|signature unpacking>
X<|subsignature>

The brackets in the signature tell the compiler to expect a list-like argument.
Instead of binding to an array parameter, it instead I<unpacks> its arguments
into several parameters--in this case, a scalar for the first element and an
array for the rest.  This I<subsignature> also acts as a constraint on the
array parameter: the signature binding will fail unless the list in the capture
contains at least one item.

Likewise you can unpack a hash by using C<%(...)> instead of square brackets,
but you must access named parameters instead of positional.

=begin code

    sub create-world(%(:$temporary, *%characteristics)) {
        my $world = World.new(%characteristics);
        return $world if $temporary;

        save-world($world);
    }

=end code

=begin sidebar

# TODO: come up with a good example
# maybe steal something from http://jnthn.net/papers/2010-yapc-eu-signatures.pdf

# TODO: generic object unpacking

=end sidebar

=head1 Currying


=begin sidebar

This explains some of the I<why> of currying, but not much of the I<what>.  Is
that necessary?  Also, I<currying> or I<partial application>?

=end sidebar

Consider a module that provided the example from the "Optional Parameters"
section:

=begin code

    sub order-burger( $type, $side? ) { ... };

=end code

If you used C<order-burger> repeatedly, but often with a side of french fries,
you might wish that the author had also provided a C<order-burger-and-fries>
sub.  You could easily write it yourself:

=begin code

    sub order-burger-and-fries ( $type ) {
        order-burger( $type, side => 'french fries' );
    }

=end code

If your personal order is always vegetarian, you might instead wish for a
C<order-the-usual> sub. This is less concise to write, due to the optional
second parameter:

=begin code

    sub order-the-usual ( $side? ) {
        if ( $side.defined ) {
            order-burger( 'veggie', $side );
        }
        else {
            order-burger( 'veggie' );
        }
    }

=end code

Currying gives you a shortcut for these exact cases; it creates a new sub from
an existing sub, with parameters already filled in. In Perl 6, curry with the
C<.assuming> method:

=begin code

    &order-the-usual        := &order-burger.assuming( 'veggie' );
    &order-burger-and-fries := &order-burger.assuming( side => 'french fries' );

=end code

The new sub is like any other sub, and works with all the various
parameter-passing schemes already described.

=begin code

    order-the-usual( 'salsa' );
    order-the-usual( side => 'broccoli' );

    order-burger-and-fries( 'plain' );
    order-burger-and-fries( :type<<double-beef>> );

=end code

=head1 Introspection

Subroutines and their signatures are objects like any other. Besides calling
them, you can learn things about them, including the details of their
parameters:

=begin code

    sub logarithm(Numeric $x, Numeric :$base = exp(1)) {
        log($x) / log($base);
    }

    my @params = &logarithm.signature.params;
    say @params.elems, ' parameters';

    for @params {
        say "Name:       ", .name;
        say "  Type:     ", .type;
        say "  named?    ", .named    ?? 'yes' !! 'no';
        say "  slurpy?   ", .slurpy   ?? 'yes' !! 'no';
        say "  optional? ", .optional ?? 'yes' !! 'no';
    }

=end code

=begin screen

    2 parameters
    Name:       $x
      Type:     Numeric()
      named?    no
      slurpy?   no
      optional? no
    Name:       $base
      Type:     Numeric()
      named?    yes
      slurpy?   no
      optional? yes

=end screen

The C<&> sigil followed by a subroutine name gets the object representing that
subroutine. C<&logarithm.signature> returns the signature associated with the
subroutine, and calling C<.params> on the signature returns a list of
C<Parameter> objects. Each of these objects describes one parameter in detail.

=begin table :caption('Methods in the Parameter class')
        method          description
 ---------------|--------------------
name                The name of the lexical variable to bind to, if any
type                The nominal type
constraints         Any further type constraints
readonly            True if the parameter has C<is readonly> trait
rw                  True if the parameter has C<is rw> trait
copy                True if the parameter has C<is copy> trait
named               True if the parameter is to be passed by name
named_names         List of names a named parameter can be passed as
slurpy              True if the parameter is slurpy
optional            True if the parameter is optional
default             A closure returning the default value
signature           A nested signature to bind the argument against
=end table


=begin sidebar

# TODO: talk about C<&signature.cando> once that's implemented

=end sidebar

Signature introspection allows you to build interfaces that can obtain and then
pass the right data to a subroutine. For example, you could build a web form
generator that knew how to get input from a user, validate it, and then call a
routine with it based upon the information obtained through introspection.  A
similar approach might generate a command line interface along with some basic
usage instructions.


=begin sidebar

Link to traits section.

=end sidebar

Beyond this, traits (L<traits>) allow you to associate extra data with
parameters.  This metadata can go far beyond that which subroutines,
signatures, and parameters normally provide.


=end pod
