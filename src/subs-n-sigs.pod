=begin pod
=NAME Подпрограммы и сигнатуры

X<|подпрограмма;аргументы;сигнатура;возвращаемое значение>

I<Подпрограмма> представляет собой участок кода, выполняющий определенную задачу. Она может оперировать передаваемыми ей при вызове данными I<(аргументами)> и может производить результаты I<(возвращаемые значения)>. I<Сигнатурой> подпрограммы является описание всех передаваемых при вызове аргументов и любых возвращаемых значений.

Первая глава демонстрирует простые подпрограммы. Операторы, описанные во второй главе, являются подпрограммами, которые Perl 6 обрабатывает необычным способом. Однако, они будут описаны поверхностно насколько это возможно.

=head1 Определение подпрограмм

X<|подпрограммы, определение>

Определение подпрограммы состоит из нескольких частей. Сперва следует декларатор C<sub>, указывающий начало определения подпрограммы. Затем - необязательное имя и необязательная сигнатура. И наконец - тело подпрограммы: ограниченный фигурными скобками блок кода. Этот код выполняется каждый раз при вызове подпрограммы.

К примеру, в коде:

=begin code

    sub panic() {
        say "Oh no! Something has gone most terribly wrong!";
    }

=end code

... определена подпрограмма с именем C<panic>. Ее сигнатура отсутствует, а тело состоит их единственного оператора C<say>.

X<|область видимости, подпрограммы; подпрограммы, область видимости>

По умолчанию, подпрограммы ограничена областью лексической видимости, как и любая переменная объявленная с помощью C<my>. Это подразумевает, что подпрограмма может быть вызвана, только в границах той области видимости I<( Как правило это блок кода )>, внутри которой она была определена. Чтобы подпрограмма стала доступной внутри всего пакета используется декларатор I<(ключевое слово)> C<our>:

=begin code
    {
        our sub eat() {
            say "om nom nom";
        }

        sub drink() {
            say "glug glug";
        }
    }

    eat();    # om nom nom
    drink();  # fails, can't drink outside of the block
=end code

C<our> также делает подпрограмму видимой вне пакета или модуля:

=begin code
    module EatAndDrink {
         our sub eat() {
             say "om nom nom";
         }

         sub drink() {
             say "glug glug";
         }
    }
    EatAndDrink::eat();    # om nom nom
    EatAndDrink::drink();  # fails, not declared with "our"
=end code

Чтобы подпрограмма стала доступна в другой области видимости, используется экспорт (см. I<Экспортирование>).

X<| анонимные подпрограммы; подпрограммы, анонимные; подпрограммы, первого класса>

Подпрограммы в Perl 6 представляют собой объекты. Их можно передавать и хранить в составе структур данных, а так производить те же действия, что и по отношению к другим данным. Дизайнеры языков программирования часто называют их I<подпрограммами первого класса>. Они являются такими же основополагающими для использования в языке, как и хэши или массивы.

Подпрограммы первого класса позволяют решать сложные задачи. Например, для создания небольшого ASCII рисунка с изображением танцующих фигур, возможно построение хэша, ключами которого будут названия движений в танце, а значениями - анонимные подпрограммы. Допустим, что пользователи могут вводить названия списки движений I<( возможно с коврика для танцев или другого экзотического устройства)>. Как можно организовать легко изменяемый список движений, а также возможно безопасно сделать проверку вводимых пользователем названий движений на предмет допустимых ? Возможно следующая структура программы станет отправной точкой для достижения результата:

=begin code

    my $dance = '';
    my %moves =
        hands-over-head => sub { $dance ~= '/o\ '   },
        bird-arms       => sub { $dance ~= '|/o\| ' },
        left            => sub { $dance ~= '>o '    },
        right           => sub { $dance ~= 'o< '    },
        arms-up         => sub { $dance ~= '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        %moves{$move}.();
    }

    say $dance;

=end code

На основании вывода этой программы, вы сможете убедиться что танец YMCA N< Возможно имеется в виду L<Y.M.C.A.|http://en.wikipedia.org/wiki/Y.M.C.A._%28song%29>> также плохо выглядит в ASCII виде, как и в реальной жизни.

=head1 Добавление сигнатур
X<|параметры; подпрограммы, синатуры; сигнатуры, подпрограмм>

Сигнатура подпрограммы решает две задачи. Во первых, она объявляет список обязательных и необязательных аргументов, передаваемых при вызове подпрограммы. Во вторых, с помощью сигнатуры объявляются переменные и их связь с аргументами подпрограммы. Эти переменные называются I<параметрами>. Сигнатуры в Perl 6 обладают дополнительными возможностями: они позволяют ограничивать значения аргументов, сравнивать и извлекать сложные структуры данных.

=head2 Основы

В своей простой форме сигнатура - список разделенных запятой имен переменных, с которыми связываются входные аргументы подпрограммы.

=begin code

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer('Hobgoblin', 1);    # A pint of Hobgoblin, please.
    order-beer('Zlatц+ Baе+ant', 3); # 3 pints of Zlatц+ Baе+ant, please.

=end code

Использование термина I<связываются> вместо I<присваиваются> весьма существенно. Переменные в сигнатуре являются ссылками в режиме "чтения" на передаваемые подпрограмме аргументы. Это делает недоступными для модификаций входные значения.

Связывание в режиме "только чтение" можно отменить. Если пометить параметр атрибутом C<is rw>, то передаваемое значение можно будет изменять. Эти изменения будут применены также к оригинальным данным, передаваемым при вызове подпрограммы. В случае, если будет передан литерал или другое константное значение для C<rw> параметра, то связывание завершиться ошибкой в месте вызова подпрограммы, вызвав программное исключение:

=begin code

    sub make-it-more-so($it is rw) {
        $it ~= substr($it, $it.chars - 1) x 5;
    }

    my $happy = "yay!";
    make-it-more-so($happy);
    say $happy;                # yay!!!!!!
    make-it-more-so("uh-oh");  # Fails; can't modify a constant

=end code

Также возможно создание копии передаваемых значений с помощью C<is copy>. В таком случае, данные вне подпрограммы будут защищены от модификаций, а внутри подпрограммы могут быть изменены:

=begin code

    sub say-it-one-higher($it is copy) {
        $it++;
        say $it;
    }

    my $unanswer = 41;
    say-it-one-higher($unanswer);  # 42
    say-it-one-higher(41);         # 42

=end code

Столь подробная маркировка изменяемых параметров может показать чрезмерной, но скорее всего вы не будете использовать эти модификаторы часто. В то время как некоторые языки требуют пометки параметров C<rw> для эмуляции возврата множественных результатов, Perl 6 позволяет напрямую возвращать несколько значений в ответе без подобных фокусов.

=head2 Передача массивов, хэшей и кода

Сигил переменной указывает на ее предназначение. В сигнатуре, сигил переменной ограничивает типы передаваемых аргументов. Например, сигил C<@> определяет проверку передаваемых значений на соответствие типу C<Positional> I<(Позиционный)>, который включает в себя типы наподобие C<Array> I<(массивов)> и списков. При передаче параметров нарушающих это ограничение на экран будет выведено сообщение об ошибке.

=begin code
    sub shout-them(@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    my @last_words = <do not want>;
    shout-them(@last_words);  # DO NOT WANT
    shout-them('help');       # Fails; a string is not Positional

=end code

Соответственно, сигил C<%> указывает, что ожидается нечто C<Associative> I<(Ассоциативное)>, т.е. что-то позволяющее индексирование с помощью операторов C<< <...> >> или
C<{...}>. В свою очередь сигил C<&> требует указания чего-то вызываемого, например анонимной подпрограммы. В таком случае производить вызов этого параметра можно без указания сигила C<&>:

=begin code

    sub do-it-lots(&it, $how-many-times) {
        for 1..$how-many-times {
            it();
        }
    }

    do-it-lots(sub { say "Eating a stroopwafel" }, 10);

=end code

Скаляр (сигил C<&>) не имеет ограничений. Что угодно может быть связано с ним, даже если оно может связываться с другими сигилами.

=head1 Интерполяция массивов и хэшей

Иногда требуется заполнить позиционные аргументы значениями из массива.
Вместо написания C<eat(@food[0], @food[1], @food[2], ...)> и так далее, вы можете линеаризовать I<(flatten)> его в список аргументов предварив вертикальной чертой: C<eat(|@food)>.

Кроме того, можно интерполировать хэши в именованные аргументы:

=begin code

    sub order-shrimps($count, $from) {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    my %user-preferences = ( from => 'Northern Sea' );
    order-shrimps(3, |%user-preferences)

=end code

=head2 Необязатльные параметры

Иногда аргументы могут быть необязательными. Например, достаточно других параметров с их значениями по умолчанию. В таких случаях подобные необязательные параметры можно пометить как опциональные. При вызовах таких подпрограмм появляется выбор в наборе передаваемых аргументов.

Либо присвоить значение параметра по умолчанию в сигнатуре :

=begin code

    sub order-steak($how = 'medium') {
        say "I'd like a steak, $how";
    }

    order-steak();
    order-steak('well done');

=end code

... или добавить знак вопроса к имени параметра. В последнем случае параметр получает неопределенное значение, если аргумент не передан:


=begin code

    sub order-burger($type, $side?) {
       say "I'd like a $type burger" ~
           ( defined($side) ?? " with a side of $side" !! "" );
    }

    order-burger("triple bacon", "deep fried onion rings");

=end code

=head2 Именованные параметры

Когда подпрограмма имеет много параметров, зачастую, проще привязывать параметры к имени вместо к их позиции в списке передаваемых аргументов. Как следствие, порядок следования аргументов при вызове становиться неважным:

=begin code

    sub order-beer($type, $pints) {
        say ($pints == 1 ?? 'A pint' !! "$pints pints") ~ " of $type, please."
    }

    order-beer(type => 'Hobgoblin', pints => 1);
    # A pint of Hobgoblin, please.

    order-beer(pints => 3, type => 'ZlatГ?? BaЕ??ant');
    # 3 pints of ZlatГ?? BaЕ??ant, please.

=end code

Возможно определить входной аргумент, который может быть передан только по имени, а не позиционно при вызове. Для этого перед именем параметра указывается двоеточие:

=begin code

    sub order-shrimps($count, :$from = 'North Sea') {
        say "I'd like $count pieces of shrimp from the $from, please";
    }

    order-shrimps(6);                       # takes 'North Sea'
    order-shrimps(4, from => 'Atlantic Ocean');
    order-shrimps(22, 'Mediterranean Sea'); # not allowed, :$from is named only

=end code

В отличии от позиционных параметров, именованные являются необязательными по умолчанию. Чтобы сделать именованный параметр обязательным необходимо добавить к имени параметра восклицательный знак C<!>.

=begin code

    sub design-ice-cream-mixture($base = 'Vanilla', :$name!) {
        say "Creating a new recipe named $name!"
    }

    design-ice-cream-mixture(name => 'Plain');
    design-ice-cream-mixture(base => 'Strawberry chip'); # missing $name

=end code

=head3 Переименование параметров

Так как требуется указывать имена при передаче именованных параметров, то данные имена являются частью общедоступного API подпрограмм. Выбирайте имена осторожно ! Иногда может оказаться полезным отделить имя параметра от имени переменной подпрограммы, с которой он связан:

=begin code

    sub announce-time(:dinner($supper) = '8pm') {
        say "We eat dinner at $supper";
    }

    announce-time(dinner => '9pm');      # We eat dinner at 9pm

=end code

Параметры могут иметь несколько имен ! Если часть пользователей британцы, а остальные - американцы, то можно написать:

=begin code

    sub paint-rectangle(
            :$x      =   0,
            :$y      =   0,
            :$width  = 100,
            :$height =  50,
            :color(:colour($c))) {

       # print a piece of SVG that reprents a rectangle
       say qq[<rect x="$x" y="$y" width="$width" height="$height"
                     style="fill: $c" />]
    }

    # both calls work the same
    paint-rectangle :color<Blue>;
    paint-rectangle :colour<Blue>;

    # of course you can still fill the other options
    paint-rectangle :width(30), :height(10), :colour<Blue>;

=end code

=head3 Альтернативный синтаксис Именованных параметров

Именованные параметры на самом деле являются C<Парами> ( C<Pair>, пара ключ - значение). Существует несколько способов описания C<Пар>. Отличаются они степенью наглядности, так как каждый вариант предусматривает различные механизмы оформления. Следующие три вызова эквивалентны:

=begin code

    announce-time(dinner => '9pm');
    announce-time(:dinner('9pm'));
    announce-time(:dinner<9pm>);

=end code

Если передается логическое значение, то достаточно определения ключа:

=begin code

    toggle-blender( :enabled); # enables  the blender
    toggle-blender(:!enabled); # disables the blender

=end code

Именованный параметр C<:name> без указанного значения подразумевает неявное логическое значение C<Bool::True>. Противоположная форма, C<:!name>, указывает на неявное значение C<Bool::False>.

При создании пары, ключ которой совпадает с именем переменной, возможна следующая форма:

=begin code

    my $dinner = '9pm';
    announce-dinner :$dinner;  # same as dinner => $dinner;

=end code

В следующей таблице приведены возможные формы Пар и их значения.


=begin table :caption('Формы Пар и их значения')
 Краткая форма              Полная форма               Описание
 ------------------|-------------------------------|---------
 C<< :allowed >>    C<< allowed => Bool::True >>        Логичекий флаг
 C<< :!allowed >>   C<< allowed => Bool::False >>       Логичекий флаг
 C<< :bev<tea coffee> >>    C<< bev => ('tea', 'coffee') >>     Список
 C<< :times[1, 3] >>    C<< times => [1, 3] >>          Массив
 C<< :opts{ a => 2 } >>     C<< opts => { a => 2 } >>       Хэш
 C<< :$var >>           C<< var => $var >>          Скалярная переменная
 C<< :@var >>           C<< var => @var >>          Переменная - массив
 C<< :%var >>           C<< var => %var >>          Переменная - хэш

=end table

Возможно использование любой из указанных форм в любом контексте, где возможно использование объекта C<Pair>.Например, для заполнения массива:

=begin code

    # TODO: better example
    my $black = 12;
    my %color-popularities = :$black, :blue(8),
                             red => 18, :white<0>;
    # same as
    # my %color-popularities = 
    #       black => 12,
    #       blue  => 8,
    #       red   => 18,
    #       white => 0;

=end code

И наконец, чтобы передать существующий объект C<Pair> в подпрограмму как позиционный параметр I<(не именнованный)>, необходимо либо заключить его в круглые скобки ( C<(:$thing)> ), либо использовать оператор C<< => >> с взятой в кавычки левой частью:  C<< "thing" => $thing >>.

=head3 Последовательность параметров

Когда используются в сигнатуре оба типа параметров, позиционные и именованные, то все позиционные параметры должны быть указаны перед именованными.

=begin code

    sub mix(@ingredients, :$name) { ... }    # OK
    sub notmix(:$name, @ingredients) { ... } # Error

=end code

Обязательные позиционные параметры также должны быть указаны перед опциональными I<(необязательными)> позиционными. Для именованных параметров нет подобных требований.

=head2 Slurpy параметры

X<|slurpy>

В приведенном ранее примере функция C<shout-it> ожидала массив в качестве аргумента. Это предотвращало передачу одиночного аргумента. Что бы сделать возможным передачу нескольких позиционных аргументов и даже  массивов аргументов, которые будут затем в подпрограмме выравнены I<(flatten)> в один аргумент "массив", необходимо предварить имя параметра I<slurpy> префиксом (C<*>):

=begin code

    sub shout-them(*@words) {
        for @words -> $w {
            print uc("$w ");
        }
    }

    # now you can pass items
    shout-them('go');           # GO
    shout-them('go', 'home');   # GO HOME

    my @words = ('go', 'home');
    shout-them(@words);         # still works

=end code

Slurpy параметр I<( параметр с прешествующeй его имени звездочкой C<*> )> сохраняет ожидаемые позиционные параметры в массив. Кроме того, C<*%hash> захватывает N<slurp, переводиться как - хлебать> все входящие несвязанные именованные аргументы в хэш.

Slurpy массивы  и хши позволяют передавать все позиционные и именованные параметры в другом порядке:

=begin code

    sub debug-wrapper(&code, *@positional, *%named) {
        warn "Calling '&code.name()' with arguments "
             ~ "@positional.perl(), %named.perl()\n";
        code(|@positional, |%named);
        warn "... back from '&code.name()'\n";
    }

    debug-wrapper(&order-shrimps, 4, from => 'Atlantic Ocean');

=end code

=head1 Возращаемые результаты

Подпрограммы могут также возвращать результаты. Пример, описанный ранее, с танцами в виде ASCII графики упрощается при использовании подпрограмм, возвращающих новые строки: 

=begin code

    my %moves =
       hands-over-head => sub { return '/o\ '   },
       bird-arms       => sub { return '|/o\| ' },
       left            => sub { return '>o '    },
       right           => sub { return 'o< '    },
       arms-up         => sub { return '\o/ '   };

    my @awesome-dance = <arms-up bird-arms right hands-over-head>;

    for @awesome-dance -> $move {
        print %moves{$move}.();
    }

    print "\n";

=end code

Подпрограммы в Perl могут возвращать несколько результатов:

=begin code

    sub menu {
        if rand < 0.5 {
            return ('fish', 'white wine')
        } else {
            return ('steak', 'red wine');
        }
    }

    my ($food, $beverage) = menu();

=end code

X<|return>

Если опустить оператор C<return>, Perl вернет значение последнего оператора,   выполненного внутри подпрограммы. Это упрощает предидущий пример:

=begin code

    sub menu {
        if rand < 0.5 {
            'fish', 'white wine'
        } else {
            'steak', 'red wine';
        }
    }

    my ($food, $beverage) = menu();

=end code

X<|return, implicit>

Будьте осторожны, прежде чем полностью полагаться на это: в случае сложной логики I<(условные переходы, несколько точек завершения)> добавление C<return> позволит сделать код нагляднее. В качестве общего правила можно принять следующее утверждение: использование неявного C<return> имеет положительный эффект только в простых подпрограммах.

C<return> имеет дополнительный эффект при раннем завершении подпрограммы:

=begin code

    sub create-world(*%characteristics) {
        my $world = World.new(%characteristics);
        return $world if %characteristics<temporary>;

        save-world($world);
    }

=end code

... в таком случае новая переменная C<$world> точно не будет потеряна и будет возвращена в качестве ответа.

=head1 Работа с типами

Зачастую подпрограммы не могут осмысленно работать с произвольными входными данными и требуют поддержки определенных методом или свойств от входных параметров. В таких случаях имеет смысл ограничить типы передаваемых параметров, так чтобы передача неверных значений в качестве аргументов подпрограммы приводило к ошибке во время вызова.

=head2 Базовые типы

X<|constraint, type>
X<|parameter type constraint>

Наиболее простой путь ограничить допустимые передаваемые значения аргументов -  указать имя типа перед параметром. Например, подпрограмма, производящая математические операции над своими параметрами, ожидает аргументы с типом C<Numeric>:

=begin code

    sub mean(Numeric $a, Numeric $b) {
        return ($a + $b) / 2;
    }

    say mean 2.5, 1.5;
    say mean 'some', 'strings';

=end code

Результат работы будет следующим:

=begin screen

    2
    Nominal type check failed for parameter '$a';
        expected Numeric but got Str instead

=end screen

Если несколько параметров имеют ограничения по типу, то каждый из аргументов должен соответствовать ограничениям параметра, с которым он связан.

=head2 Добавление ограничений

X<|constraint>
X<|where>

Иногда указание имени типа недостаточно для описания требований к аргументу. В таких случаях указывается дополнительное I<ограничение> для параметра с помощью блока C<where>:

=begin code

    sub circle-radius-from-area(Numeric $area where { $area >= 0 }) {
        ($area / pi).sqrt
    }

    say circle-radius-from-area(3);    # OK
    say circle-radius-from-area(-3);   # Error

=end code

Так как расчет имеет смысл только для неотрицательных чисел, дополнительное ограничение возвращает C<True> при соответствии входных значений этому диапазону. Если ограничение возвращает значение "Ложь", проверка завершается ошибкой.

Блок после C<where> необязательный. Perl выполняет проверку посредством "умного" сопоставления, используя в качестве аргументов все, что находится после C<where>. Таким образом возможно явное указание диапазона:

=begin code

    sub set-volume(Numeric $volume where 0..11) {
        say "Turning it up to $volume";
    }

=end code

Для ограничения аргументов существующими ключами хэша:

=begin code

    my %in-stock = 'Staropramen' => 8, 'Mori' => 5, 'La Trappe' => 9;

    sub order-beer(Str $name where %in-stock) {
        say "Here's your $name";
        %in-stock{$name}--;
        if %in-stock{$name} == 0 {
            say "OH NO! That was the last $name, folks! :'(";
            %in-stock.delete($name);
        }
    }

=end code

=head1 Захватывания

X<|captures>
X<|Capture>

В каком-то смысле, сигнатура представляет собой I<"коллекцию"> аргументов. Захватывания I<(captures)> представляют собой сущности того же уровня. Так же, как вы редко думаете о сигнатуре в целом, сосредотачиваясь на каждом отдельно взятом параметре, так же редко вы должны редко думать о I<"захватываниях">. Однако, Perl 6 позволяет управлять захватываниями напрямую.
Захватывания состоят из позиционных и именованных частей, которые действуют аналогично спискам и хэшам соответственно. Списочная часть содержит позиционные аргументы, а хэш составляющая  - именованные аргументы.

=head2 создание и использование захватываний

Чтобы создать I<захватывание>, используется C<\(...)> синтаксис. Подобно массивам и хэшам, можно интерполировать захватывание в один аргумент с помощью C<|>:

=begin code

    sub act($left, $right, :$action) {
        $action($left, $right);
    }

    my @tasks = \(39, 3, action => { say $^a + $^b }),
                \(6, 7, action => { say $^a * $^b });

    for @tasks -> $task-args {
        act(|$task-args);
    }

=end code

Эта программа создает массив "захватываний", каждое из которых содержит два позиционных аргумента и один именованный. При выполнении цикла по элементам массива выполняется вызов C<act>, аргументы которого заполняются содержимым захватывания.
Perl 6 позволяет отдельно определить аргументы для вызова и сам вызов. Как следствие, это позволяет использовать одни и те же аргументы для многократных вызовов, а также использовать вызов для разных наборов аргументов. Коду приложения не обязательно знать является ли аргумент позиционным или именованным.
В отличии от сигнатур, захватывания работают аналогично ссылкам. Любая переменная, указанная в "захватывании", представлена как I<ссылка> на переменную.Таким образом C<rw> параметры продолжают работать при использовании "захватываний".

=begin code

    my $value     = 7;
    my $to-change = \($value);

    sub double($x is rw) {
        $x *= 2;
    }

    sub triple($x is rw) {
        $x *= 3;
    }

    triple(|$to-change);
    double(|$to-change);

    say $value; # 42

=end code

Типы Perl с позиционными и именованными частями встречаются также в других ситуациях. Например, регулярные выражения имеют позиционные и именованные выражения: объекты типа C<Match> представляют собой "захватывания".  Также возможно представить XML узлы одним из видов "захватываний", включающих в себя именованные атрибуты и позиционные потомки. Привязка такого узла к функции позволяет использовать единый синтаксис параметров для работы с различными потомками атрибутами.

=head2 Захватывания в Сигнатурах

Все вызовы создают захватывания на этапе вызова и разворачивают их в соответствии с сигнатурой внутри вызова N<Оптимизатор Perl 6 может, конечно, допускать оптимизации на любом из этих этапов, в зависимости от информации, которая может быть доступна на этапе компиляции.>. Это позволяет написать сигнатуру, которая свяжет само "захватывание" с переменной. Это особенно полезно при написании процедур, которые делегируют управление другим процедурам с теми же параметрами.


=begin code

    sub visit-czechoslovakia(|$plan) {
        warn "Sorry, this country has been deprecated.";
        visit-slovakia(|$plan);
        visit-czech-republic(|$plan);
    }

=end code

Преимущества такого использования в сравнении с сигнатурой вида C<:(*@pos, *%named)> заключаются в отсутствии некоторого контекста в аргументах, который может быть преждевременным.
Например, если при вызове передаются два массива, они будут линеаризованы в C<@pos>. Это значит, что в дальнейшем эти два массива не могут быть восстановлены в оригинальном виде. "Захватывание" сохраняет аргументы из двух массивов, что поможет при связывании их в сигнатурах вызываемых в итоге подпрограмм.


=head1 Unpacking

В некоторых случаях требуется работать только с частью массива или хэша. Для этого можно использовать обычный доступ к срезам, а также сигнатурное связывание:

=begin code

    sub first-is-largest(@a) {
        my $first = @a.shift;
        # TODO: either explain junctions, or find a
        # concise way to write without them
        return $first >= all(@a);
    }

    # same thing:
    sub first-is-largest(@a) {
        my :($first, *@rest) := \(|@a)
        return $first >= all(@rest);
    }

=end code

Сигнатурное связывание может показаться неуклюжим, но при использовании в основной сигнатуре подпрограммы, открывается истинная сила.

=begin code

    sub first-is-largest([$first, *@rest]) {
        return $first >= all(@rest);
    }

=end code

X<|unpacking>
X<|signature unpacking>
X<|subsignature>

Скобки в сигнатуре указывают компилятору ожидать списочный аргумент. Вместо привязки к массиву, компилятор I<распаковывает> аргументы в последовательность параметров, в данном примере - в скаляр для первого элемента и массив для последующих. Приведенная  I<подсигнатура> также содержит дополнительное условие: сигнатурное связывание завершится неудачей, если в передаваемом массиве будет меньше двух элементов. 

Таким же образом можно распаковать хэш, используя C<%(...)> вместо квадратных скобок. В таком случае доступны только именованные параметры, а не позиционные.

=begin code

    sub create-world(%(:$temporary, *%characteristics)) {
        my $world = World.new(%characteristics);
        return $world if $temporary;

        save-world($world);
    }

=end code

=begin sidebar

# TODO: come up with a good example
# maybe steal something from http://jnthn.net/papers/2010-yapc-eu-signatures.pdf

# TODO: generic object unpacking

=end sidebar

=head1 Карринг


Рассмотрим модуль, предложенный в качестве примера в секции "Необязательные параметры":

=begin code

    sub order-burger( $type, $side? ) { ... };

=end code

Если вы часто используете C<order-burger> и в основном вместе с картофелем фри, то наличие процедуры C<order-burger-and-fries> может оказаться кстати:

=begin code

    sub order-burger-and-fries ( $type ) {
        order-burger( $type, side => 'french fries' );
    }

=end code

Если персональный заказ всегда вегетарианский, то может понадобится процедура C<order-the-usual> с необязательным параметром:

=begin code

    sub order-the-usual ( $side? ) {
        if ( $side.defined ) {
            order-burger( 'veggie', $side );
        }
        else {
            order-burger( 'veggie' );
        }
    }

=end code

Карринг позволяет создавать сокращения для подобных применений. С помощью карринга создается новая подпрограмма на основе существующей с некоторыми предустановленными параметрами. В Perl 6, карринг создается методом C<.assuming>:

=begin code

    &order-the-usual        := &order-burger.assuming( 'veggie' );
    &order-burger-and-fries := &order-burger.assuming( side => 'french fries' );

=end code

Новая подпрограммы похожи на другие и поддерживают одни и те же структуры входных параметров.

=begin code

    order-the-usual( 'salsa' );
    order-the-usual( side => 'broccoli' );

    order-burger-and-fries( 'plain' );
    order-burger-and-fries( :type<<double-beef>> );

=end code

=head1 Интроспекция/самоанализ

Подпрограммы и их сигнатуры являются объектами. Кроме использования, имеется возможность некоторые их подробности и детали параметров:

=begin code

    sub logarithm(Numeric $x, Numeric :$base = exp(1)) {
        log($x) / log($base);
    }

    my @params = &logarithm.signature.params;
    say @params.elems, ' parameters';

    for @params {
        say "Name:       ", .name;
        say "  Type:     ", .type;
        say "  named?    ", .named    ?? 'yes' !! 'no';
        say "  slurpy?   ", .slurpy   ?? 'yes' !! 'no';
        say "  optional? ", .optional ?? 'yes' !! 'no';
    }

=end code

=begin screen

    2 parameters
    Name:       $x
      Type:     Numeric()
      named?    no
      slurpy?   no
      optional? no
    Name:       $base
      Type:     Numeric()
      named?    yes
      slurpy?   no
      optional? yes

=end screen

Сигил  C<&>  и следующее за ним имя подпрограммы представляют собой объект соответствующей подпрограммы.  C<&logarithm.signature> возвращает сигнатуру подпрограммы, а метод C<.params> у сигнатуры - список параметров в виде объектов типа C<Parameter>. Объекты C<Parameter> описывают детали каждого параметра в отдельности


=begin table :caption('Методы класса Parameter')
        method          description
 ---------------|--------------------
name                Имя связанной лексической переменной
type                Номинальный тип
constraints         Все дальнейшие ограничения типа
readonly            "Истина", если параметр C<is readonly>
rw                  "Истина", если параметр C<is rw> 
copy                "Истина", если параметр C<is copy>
named               "Истина", если параметр должен быть передан как именованный
named_names         Список названий именованных параметров
slurpy              "Истина", если параметр slurpy (захватывает)
optional            "Истина", если параметр необязательный
default             Замыкание возвращающее значение по умолчанию
signature           Вложенная сигнатура для установки привязок аргументов
=end table


=begin sidebar

# TODO: talk about C<&signature.cando> once that's implemented

=end sidebar

Анализ сигнатур позволяет создавать интерфейсы, которые могут анализировать ожидаемые сигнатурами данные, а затем передавать правильные данные в подпрограммы. Например, возможно создание программы-генератора web форм, которая будет создавать интерфейс пользователем, проверять введенные данные и затем обрабатывать их на основе информации полученной с помощью анализа сигнатур. Подобный подход позволяет также облегчить создание инструментов для работы в командной строке, обеспечивая справочную информацию о параметрах ввода.



=begin sidebar

Link to traits section, которой еще пока нет.

=end sidebar

Помимо этого, I<черты> позволяют связать с параметрами дополнительные данные. Эти метаданные выходят далеко за границы материала о подпрограммах, сигнатурах и параметрах.

=end pod
